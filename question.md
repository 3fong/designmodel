## 问题

### ????AtomicInteger是否符合单一职责原则和接口隔离原则


```

/**
 * Atomically increments by one the current value.
 * @return the previous value
 */
public final int getAndIncrement() {//...}
```
java.util.concurrent 并发包提供了 AtomicInteger 这样一个原子类，其中有一个函数 getAndIncrement() 是这样定义的：给整数增加一，并且返回未増之前的值。我的问题是，这个函数的设计是否符合单一职责原则和接口隔离原则？为什么？

答: 符合单一职责原则,因为函数内聚的完成了数值的获取和新增,它是一个整体功能;     
不满足接口隔离原则:因为返回值是旧值,这样获取操作和新增操作其实是两个操作,针对获取来说,新增是不必要的行为.


### 依赖注入与基于接口而非实现的异同

1. 核心原则都是不直接依赖实现;而是依赖引用,提高代码依赖复用性.
    这里复用性:依赖注入是对象创建复用,是生命周期的延长;接口的复用是调用方代码的复用;
2. 依赖注入是更宽泛的实现方式,它可以是类和接口;而基于接口而非实现是一种原则,只适用于接口.

### 如何看待重复造轮子?什么时候重复造轮子?什么使用现成工具类和开源框架?

造轮子肯定是有成本的,当现有轮子满足自己的需要时优先选择现有的;    
通用功能不适合重复造轮子,但是核心技术都要自研.这里自研并非完全自己开发,可以基于某个基准二次开发;    
实际开发中优先使用工具类和开源框架,当不满足实际需求时再考虑自研;

### ??? 代码重复,除了实现逻辑重复、功能语义重复和代码执行重复是否还有其他的


### ??? “高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗

高内聚,松耦合:是整体设计思想.其他四种原则都是它的一种实现指导    
单一职责原则:针对的是模块、类、接口的设计.按职责划分单一的类,代码内聚性高,但是耦合度可能还是较强;    
接口隔离原则:面向调用者的接口设计.较单一职责原则更细粒度的分类划分.只依赖自己需要的接口.耦合度低;    
基于接口而非实现编程:从使用者角度出发.通过接口引用外部依赖,避免生命周期耦合;    
迪米特法则:从对外关系出发.    






