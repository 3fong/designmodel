## 行为型模式4

### 访问者模式

Visitor Design Pattern:允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。

[访问者结构](https://upload-images.jianshu.io/upload_images/7345261-f1b6fe6189c026da.png?imageMogr2/auto-orient/strip|imageView2/2/w/840/format/webp)

它通过分离操作行为和对象的声明,通过抽象操作行为来支持操作行为对于变化的扩展能力.实际上打破了面向对象的封装性.
代码也会变的不太易于理解,可读性和可维护性变差.

核心是利用抽象行为结构+多态+编译时确定重写方法.

#### 模式演变示例

需求: 对于不同文本格式的文件进行文本内容提取;比如:PdfFile、PPTFile、WordFile

这里其实对于文本提取操作有隐形的扩展要求,因为文本格式很多,这种扩展性要求基本是必须的.

- version1: 通过抽象父类抽象行为来支持行为扩展

```
public abstract class ResourceFile {
  protected String filePath;
  public ResourceFile(String filePath) {
    this.filePath = filePath;
  }
  public abstract void extract2txt();
}

public class PPTFile extends ResourceFile {
  @Override
  public void extract2txt() { }
}
public class PdfFile extends ResourceFile {
  @Override
  public void extract2txt() { }
}
public class WordFile extends ResourceFile {
  @Override
  public void extract2txt() {}
}

public class ToolApplication {
  public static void main(String[] args) {
    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);
    for (ResourceFile resourceFile : resourceFiles) {
      resourceFile.extract2txt();
    }
  }

  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {
    List<ResourceFile> resourceFiles = new ArrayList<>();
    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)
    resourceFiles.add(new PdfFile("a.pdf"));
    resourceFiles.add(new WordFile("b.word"));
    resourceFiles.add(new PPTFile("c.ppt"));
    return resourceFiles;
  }
}
```

抽象方法的问题:

1 违背开闭原则.功能扩展只能继续在抽象父类中增加抽象接口,且要修改所有子类;    
2 可读性,可维护性变差.因为功能扩展是预期中的,所以随着功能扩展,代码也会膨胀;    
3 继承会造成耦合.上层的业务逻辑会耦合到子类,导致类的职责不单一.


- 安装访问者模式进行代码改进
抽取业务行为到单独的类中,按需调用,实现结构声明和行为的解耦
```
public abstract class ResourceFile {
  protected String filePath;
  public ResourceFile(String filePath) {
    this.filePath = filePath;
  }
}
public class PdfFile extends ResourceFile {
  public PdfFile(String filePath) {
    super(filePath);
  }
}
//...PPTFile、WordFile代码省略...
public class Extractor {
  public void extract2txt(PPTFile pptFile) {
    System.out.println("Extract PPT.");
  }

  public void extract2txt(PdfFile pdfFile) {
    System.out.println("Extract PDF.");
  }

  public void extract2txt(WordFile wordFile) {
    System.out.println("Extract WORD.");
  }
}

public class ToolApplication {
  public static void main(String[] args) {
    Extractor extractor = new Extractor();
    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);
    for (ResourceFile resourceFile : resourceFiles) {
      // 这里编译时会报错,因为无法没有定义父类的重载方法
      extractor.extract2txt(resourceFile);
    }
  }
  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {
    List<ResourceFile> resourceFiles = new ArrayList<>();
    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)
    resourceFiles.add(new PdfFile("a.pdf"));
    resourceFiles.add(new WordFile("b.word"));
    resourceFiles.add(new PPTFile("c.ppt"));
    return resourceFiles;
  }
}
```

上面extractor.extract2txt(resourceFile)会报错原因:多态是一种动态绑定，可以在运行时获取对象的实际类型，来运行实际类型对应的方法。而函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明类型执行声明类型对应的方法.    
同时Extractor中必须声明三个同种结构的方法,因为它的实现方式不同;

上面的问题,可以通过在结构类中增加显示的行为方法调用解决,但是这样又会回到行为耦合的问题:

```
public class PdfFile extends ResourceFile {
  public PdfFile(String filePath) {
    super(filePath);
  }

  @Override
  public void accept(Extractor extractor) {
    // 显示行为调用,解决直接调用编译异常
    extractor.extract2txt(this);
  }
}

public class ToolApplication {
  public static void main(String[] args) {
    Extractor extractor = new Extractor();
    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);
    for (ResourceFile resourceFile : resourceFiles) {
      // 通过泛型特性来触发特定的类方法
      resourceFile.accept(extractor);
    }
  }
}
```

但是上面的解决方式依旧存在新增方式大量修改的问题;这种方式适用于,单个类型的方法进行纵向扩展,即只会新增文本类型,这样提取文本的行为就是通用的,这样可以保证结构声明不用修改,实现类方法的扩展.

- 抽象行为来支持横向变化扩展

```
public abstract class ResourceFile {
  protected String filePath;
  public ResourceFile(String filePath) {
    this.filePath = filePath;
  }
  abstract public void accept(Visitor vistor);
}
public class PdfFile extends ResourceFile {
  public PdfFile(String filePath) {
    super(filePath);
  }
  @Override
  public void accept(Visitor visitor) {
    visitor.visit(this);
  }
}
//...PPTFile、WordFile跟PdfFile类似，这里就省略了...

// 访问者模式核心,通过多态抽象行为声明来支持方法参数的动态选择(其实是对于方法参数编译时确定的适配)
public interface Visitor {
  void visit(PdfFile pdfFile);
  void visit(PPTFile pdfFile);
  void visit(WordFile pdfFile);
}

public class Extractor implements Visitor {
  @Override
  public void visit(PPTFile pptFile) {}
  @Override
  public void visit(PdfFile pdfFile) {}
  @Override
  public void visit(WordFile wordFile) {}
}

public class Compressor implements Visitor {
  @Override
  public void visit(PPTFile pptFile) {  }
  @Override
  public void visit(PdfFile pdfFile) {  }
  @Override
  public void visit(WordFile wordFile) {  }
}

public class ToolApplication {
  public static void main(String[] args) {
    Extractor extractor = new Extractor();
    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);
    for (ResourceFile resourceFile : resourceFiles) {
      resourceFile.accept(extractor);
    }

    Compressor compressor = new Compressor();
    for(ResourceFile resourceFile : resourceFiles) {
      resourceFile.accept(compressor);
    }
  }

  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {
    List<ResourceFile> resourceFiles = new ArrayList<>();
    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)
    resourceFiles.add(new PdfFile("a.pdf"));
    resourceFiles.add(new WordFile("b.word"));
    resourceFiles.add(new PPTFile("c.ppt"));
    return resourceFiles;
  }
}
```

#### 问题:上面的示例还可以使用什么模式实现?

访问者模式核心是解决族内相同方法动态访问的问题,策略模式也可以实现类似的功能.实现方式如下:

1 定义策略key和实现子类,根据key的类型进行子类方法调用.    
2 策略的创建使用抽象工厂来支持子类方法的横向扩展;    


#### 双分派语言与访问者模式

双分派语言不需要访问者模式. 

Single Dispatch:单分派语言

  执行哪个对象的方法(对象的判断),根据对象的运行时类型来决定;    
  执行对象的哪个方法(对象方法的判断),根据方法参数的编译时类型来决定;

Double Dispatch:双分派语言

  执行哪个对象的方法,根据对象的运行时类型来决定    
  执行对象的哪个方法,根据方法参数的运行时类型来决定

Dispatch:即方法的确认.一个对象调用另一个对象的方法，就相当于给它发送一条消息。这条消息起码要包含对象名、方法名、方法参数。    
Single,Double:方法判断的决定因素.Single只跟"对象"的运行时类型有关;Double:对象”和“方法参数”两者的运行时类型有关

具体到编程语言的语法机制，Single Dispatch和Double Dispatch跟多态和函数重载直接相关。当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持Single Dispatch，不支持Double Dispatch。

Java支持多态特性，代码可以在运行时获得对象的实际类型（也就是前面提到的运行时类型），然后根据实际类型决定调用哪个方法。尽管Java支持函数重载，但Java设计的函数重载的语法规则是，并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪个重载函数，而是在编译时，根据传递进函数的参数的声明类型（也就是前面提到的编译时类型），来决定调用哪个重载函数。也就是说，具体执行哪个对象的哪个方法，只跟对象的运行时类型有关，跟参数的运行时类型无关。所以，Java语言只支持Single Dispatch。

java单分派示例

```
public class ParentClass {
  public void f() {
    System.out.println("I am ParentClass's f().");
  }
}

public class ChildClass extends ParentClass {
  public void f() {
    System.out.println("I am ChildClass's f().");
  }
}

public class SingleDispatchClass {
  public void polymorphismFunction(ParentClass p) {
    p.f();
  }

  public void overloadFunction(ParentClass p) {
    System.out.println("I am overloadFunction(ParentClass p).");
  }

  public void overloadFunction(ChildClass c) {
    System.out.println("I am overloadFunction(ChildClass c).");
  }
}

public class DemoMain {
  public static void main(String[] args) {
    SingleDispatchClass demo = new SingleDispatchClass();
    ParentClass p = new ChildClass();
    demo.polymorphismFunction(p);//执行哪个对象的方法，由对象的实际类型决定
    demo.overloadFunction(p);//执行对象的哪个方法，由参数对象的声明类型决定
  }
}

//代码执行结果:
I am ChildClass's f().
I am overloadFunction(ParentClass p).
```

假设Java语言支持Double Dispatch,那么代码的方法参数就可以动态选择,也就不需要访问者模式了,这也是支持Double Dispatch的语言不需要访问者模式的原因。

```
public abstract class ResourceFile {
  protected String filePath;
  public ResourceFile(String filePath) {
    this.filePath = filePath;
  }
}

public class PdfFile extends ResourceFile {
  public PdfFile(String filePath) {
    super(filePath);
  }
}
public class Extractor {
  public void extract2txt(PPTFile pptFile) { }

  public void extract2txt(PdfFile pdfFile) { }

  public void extract2txt(WordFile wordFile) { }
}

public class ToolApplication {
  public static void main(String[] args) {
    Extractor extractor = new Extractor();
    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);
    for (ResourceFile resourceFile : resourceFiles) {
      extractor.extract2txt(resourceFile);
    }
  }
  }
```

双分派语言中由于方法参数是动态选择的,所以这里extractor.extract2txt(resourceFile)就可以正常通过编译,在运行时选择对应的重载方法.所以也就不需要访问者模式的对于重载适配了.

- 策略模式+工厂模式实现方法参数的动态匹配

```
public abstract class ResourceFile {
  protected String filePath;
  public ResourceFile(String filePath) {
    this.filePath = filePath;
  }
  public abstract ResourceFileType getType();
}

public class PdfFile extends ResourceFile {
  public PdfFile(String filePath) {
    super(filePath);
  }

  @Override
  public ResourceFileType getType() {
    return ResourceFileType.PDF;
  }

  //...
}

//...PPTFile/WordFile跟PdfFile代码结构类似，此处省略...

public interface Extractor {
  void extract2txt(ResourceFile resourceFile);
}

public class PdfExtractor implements Extractor {
  @Override
  public void extract2txt(ResourceFile resourceFile) {
    //...
  }
}

//...PPTExtractor/WordExtractor跟PdfExtractor代码结构类似，此处省略...
// 工厂模式定义
public class ExtractorFactory {
  private static final Map<ResourceFileType, Extractor> extractors = new HashMap<>();
  static {
    // 策略模式
    extractors.put(ResourceFileType.PDF, new PdfExtractor());
    extractors.put(ResourceFileType.PPT, new PPTExtractor());
    extractors.put(ResourceFileType.WORD, new WordExtractor());
  }

  public static Extractor getExtractor(ResourceFileType type) {
    return extractors.get(type);
  }
}

public class ToolApplication {
  public static void main(String[] args) {
    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);
    for (ResourceFile resourceFile : resourceFiles) {
      Extractor extractor = ExtractorFactory.getExtractor(resourceFile.getType());
      extractor.extract2txt(resourceFile);
    }
  }

  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {
    List<ResourceFile> resourceFiles = new ArrayList<>();
    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)
    resourceFiles.add(new PdfFile("a.pdf"));
    resourceFiles.add(new WordFile("b.word"));
    resourceFiles.add(new PPTFile("c.ppt"));
    return resourceFiles;
  }
}
```

- 策略模式和访问者模式的选择

如果工具提供的功能并不是非常多，只有几个而已，那我更推荐使用工厂模式的实现方式，毕竟代码更加清晰、易懂。相反，如果工具提供非常多的功能，比如有十几个，那我更推荐使用访问者模式，因为访问者模式需要定义的类要比工厂模式的实现方式少很多，类太多也会影响到代码的可维护性。

#### 问题 

- 访问者模式是否破坏的了面向对象.

是的.因为它破坏了对象的声明的统一性.但是它通过聚合行为来实现行为的扩展性,是一种扩展性的折衷方案.

- 下面示例会输出什么,为什么

```
    public void overloadFunction(Parent p) {
        p.f();
    }

    public void overloadFunction(Child c) {
        c.f();
    }

    main{
      Parent p = new Child();
        demo.overloadFunction(p);//执行对象的哪个方法，由参数对象的声明类型决定
    }
```
输出结果:

  I am ChildClass's f().  

因为无论是单分派还是双分派,哪个类的方法执行是在运行时决定的,所以会触发child.f()方法










