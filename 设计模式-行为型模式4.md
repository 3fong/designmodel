## 行为型模式4

### 访问者模式

Visitor Design Pattern:允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。

[访问者结构](https://upload-images.jianshu.io/upload_images/7345261-f1b6fe6189c026da.png?imageMogr2/auto-orient/strip|imageView2/2/w/840/format/webp)

它通过分离操作行为和对象的声明,通过抽象操作行为来支持操作行为对于变化的扩展能力.实际上打破了面向对象的封装性.
代码也会变的不太易于理解,可读性和可维护性变差.

#### 模式演变示例

需求: 对于不同文本格式的文件进行文本内容提取;比如:PdfFile、PPTFile、WordFile

这里其实对于文本提取操作有隐形的扩展要求,因为文本格式很多,这种扩展性要求基本是必须的.

- version1: 通过抽象父类抽象行为来支持行为扩展

```
public abstract class ResourceFile {
  protected String filePath;
  public ResourceFile(String filePath) {
    this.filePath = filePath;
  }
  public abstract void extract2txt();
}

public class PPTFile extends ResourceFile {
  @Override
  public void extract2txt() {
    System.out.println("Extract PPT.");
  }
}

public class PdfFile extends ResourceFile {
  @Override
  public void extract2txt() {
    System.out.println("Extract PDF.");
  }
}

public class WordFile extends ResourceFile {
  @Override
  public void extract2txt() {
    System.out.println("Extract WORD.");
  }
}

// 运行结果是：
// Extract PDF.
// Extract WORD.
// Extract PPT.
public class ToolApplication {
  public static void main(String[] args) {
    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);
    for (ResourceFile resourceFile : resourceFiles) {
      resourceFile.extract2txt();
    }
  }

  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {
    List<ResourceFile> resourceFiles = new ArrayList<>();
    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)
    resourceFiles.add(new PdfFile("a.pdf"));
    resourceFiles.add(new WordFile("b.word"));
    resourceFiles.add(new PPTFile("c.ppt"));
    return resourceFiles;
  }
}
```

抽象方法的问题:

1 违背开闭原则.功能扩展只能继续在抽象父类中增加抽象接口,且要修改所有子类;    
2 可读性,可维护性变差.因为功能扩展是预期中的,所以随着功能扩展,代码也会膨胀;    
3 继承会造成耦合.上层的业务逻辑会耦合到子类,导致类的职责不单一.










