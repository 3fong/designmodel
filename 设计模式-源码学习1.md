## 设计模式源码实现

分为两部分: 开源项目实战 和 项目实战

开源项目实战:Java JDK、Unix、Google Guava、Spring、MyBatis

项目实战:鉴权限流、幂等重试、灰度发布(设计原则、思想、模式)

### JavaJDK源码学习

#### 工厂模式在Calendar类中的应用

Calendar类提供了大量跟日期相关的功能代码，同时，又提供了一个getInstance()工厂方法，用来根据不同的TimeZone和Locale创建不同的Calendar子类对象。，因为它不单单是一个工厂类，所以，它并没有以Factory作为后缀来命名。

Calendar中使用了工厂模式和builder模式,都不是标准的实现.这里只做记录;

#### Collections 

- 装饰者模式

Collections中有很多装饰者模式的实现,这里只列举了UnmodifiableCollection,从的实现中可以看出来装饰者的典型特征:

    1 实现相同的接口;来支持多次装饰;
    2 基于组合实现装饰.通过构造方法注入,避免继承强依赖.


```
public class Collections {
  private Collections() {}
    
  public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c) {
    return new UnmodifiableCollection<>(c);
  }

  static class UnmodifiableCollection<E> implements Collection<E>,   Serializable {
    private static final long serialVersionUID = 1820017752578914078L;
    final Collection<? extends E> c;

    UnmodifiableCollection(Collection<? extends E> c) {
      if (c==null)
        throw new NullPointerException();
      this.c = c;
    }

    public int size()                   {return c.size();}
    public boolean isEmpty()            {return c.isEmpty();}
    public boolean contains(Object o)   {return c.contains(o);}
    public Object[] toArray()           {return c.toArray();}
    public <T> T[] toArray(T[] a)       {return c.toArray(a);}
    public String toString()            {return c.toString();}

    public Iterator<E> iterator() {
      return new Iterator<E>() {
        private final Iterator<? extends E> i = c.iterator();

        public boolean hasNext() {return i.hasNext();}
        public E next()          {return i.next();}
        public void remove() {
          throw new UnsupportedOperationException();
        }
        @Override
        public void forEachRemaining(Consumer<? super E> action) {
          // Use backing collection version
          i.forEachRemaining(action);
        }
      };
    }

    public boolean add(E e) {
      throw new UnsupportedOperationException();
    }
    public boolean remove(Object o) {
       hrow new UnsupportedOperationException();
    }
    public boolean containsAll(Collection<?> coll) {
      return c.containsAll(coll);
    }
    public boolean addAll(Collection<? extends E> coll) {
      throw new UnsupportedOperationException();
    }
    public boolean removeAll(Collection<?> coll) {
      throw new UnsupportedOperationException();
    }
    public boolean retainAll(Collection<?> coll) {
      throw new UnsupportedOperationException();
    }
    public void clear() {
      throw new UnsupportedOperationException();
    }

    // Override default methods in Collection
    @Override
    public void forEach(Consumer<? super E> action) {
      c.forEach(action);
    }
    @Override
    public boolean removeIf(Predicate<? super E> filter) {
      throw new UnsupportedOperationException();
    }
    @SuppressWarnings("unchecked")
    @Override
    public Spliterator<E> spliterator() {
      return (Spliterator<E>)c.spliterator();
    }
    @SuppressWarnings("unchecked")
    @Override
    public Stream<E> stream() {
      return (Stream<E>)c.stream();
    }
    @SuppressWarnings("unchecked")
    @Override
    public Stream<E> parallelStream() {
      return (Stream<E>)c.parallelStream();
    }
  }
}
```

- 适配器模式

新版本的JDK用Iterator类替代Enumeration类来遍历容器.这里通过匿名内部类重新实现了Enumeration,实现了Iterator遍历与Enumeration的hasMoreElements等遍历方法的兼容.

```
/**
 * Returns an enumeration over the specified collection.  This provides
 * interoperability with legacy APIs that require an enumeration
 * as input.
 *
 * @param  <T> the class of the objects in the collection
 * @param c the collection for which an enumeration is to be returned.
 * @return an enumeration over the specified collection.
 * @see Enumeration
 */
public static <T> Enumeration<T> enumeration(final Collection<T> c) {
  return new Enumeration<T>() {
    private final Iterator<T> i = c.iterator();

    public boolean hasMoreElements() {
      return i.hasNext();
    }

    public T nextElement() {
      return i.next();
    }
  };
}
```

- 模板模式

Collections.sort().通过默认实现+自定义回调实现扩展.

```
// arraylist重新了sort方法
    @Override
    @SuppressWarnings("unchecked")
    public void sort(Comparator<? super E> c) {
        final int expectedModCount = modCount;
        Arrays.sort((E[]) elementData, 0, size, c);
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
        modCount++;
    }

// Arrays.sort()中定义排序模板方法,没有自定义回调则使用默认方法;有则使用自定义的
        public static <T> void sort(T[] a, int fromIndex, int toIndex,
                                Comparator<? super T> c) {
        if (c == null) {
            sort(a, fromIndex, toIndex);
        } else {
            rangeCheck(a.length, fromIndex, toIndex);
            if (LegacyMergeSort.userRequested)
                legacyMergeSort(a, fromIndex, toIndex, c);
            else
                TimSort.sort(a, fromIndex, toIndex, c, null, 0, 0);
        }
    }

    // 自定义回调方法在二分查找中影响排序结果
    private static <T> void binarySort(T[] a, int lo, int hi, int start,
                                       Comparator<? super T> c) {
        assert lo <= start && start <= hi;
        if (start == lo)
            start++;
        for ( ; start < hi; start++) {
            T pivot = a[start];

            // Set left (and right) to the index where a[start] (pivot) belongs
            int left = lo;
            int right = start;
            assert left <= right;
            /*
             * Invariants:
             *   pivot >= all in [lo, left).
             *   pivot <  all in [right, start).
             */
            while (left < right) {
                int mid = (left + right) >>> 1;
                // 使用自定义回调
                if (c.compare(pivot, a[mid]) < 0)
                    right = mid;
                else
                    left = mid + 1;
            }
            assert left == right;

            /*
             * The invariants still hold: pivot >= all in [lo, left) and
             * pivot < all in [left, start), so pivot belongs at left.  Note
             * that if there are elements equal to pivot, left points to the
             * first slot after them -- that's why this sort is stable.
             * Slide elements over to make room for pivot.
             */
            int n = start - left;  // The number of elements to move
            // Switch is just an optimization for arraycopy in default case
            switch (n) {
                case 2:  a[left + 2] = a[left + 1];
                case 1:  a[left + 1] = a[left];
                         break;
                default: System.arraycopy(a, left, a, left + 1, n);
            }
            a[left] = pivot;
        }
    }
```

- 观察者模式

jdk中观察者:java.util.Observable和java.util.Observer

```
public interface Observer {
    void update(Observable o, Object arg);
}

public class Observable {
    private boolean changed = false;
    private Vector<Observer> obs;

    public Observable() {
        obs = new Vector<>();
    }

    public synchronized void addObserver(Observer o) {
        if (o == null)
            throw new NullPointerException();
        if (!obs.contains(o)) {
            obs.addElement(o);
        }
    }

    public synchronized void deleteObserver(Observer o) {
        obs.removeElement(o);
    }

    public void notifyObservers() {
        notifyObservers(null);
    }

    public void notifyObservers(Object arg) {
        Object[] arrLocal;

        synchronized (this) {
            if (!changed)
                return;
            arrLocal = obs.toArray();
            clearChanged();
        }

        for (int i = arrLocal.length-1; i>=0; i--)
            ((Observer)arrLocal[i]).update(this, arg);
    }

    public synchronized void deleteObservers() {
        obs.removeAllElements();
    }

    protected synchronized void setChanged() {
        changed = true;
    }

    protected synchronized void clearChanged() {
        changed = false;
    }
}
```

设计模式只是一种思想的实现,核心是思想含义,而不是招式.

1 changed成员变量的作用:通知触发必须要显示更新changed,这个是否有必要???        
    1 changed状态的原因是避免多线程情况下,重复通知的问题,是一个共享状态.    
    2 很多情况下,变化时并不需要通知,当突破某个阈值后再进行通知,这时changed状态能很好的支持;    
    总体上将通知与变化操作拆分,可以更灵活的控制程序.    
2 线程安全问题:    
    添加,移除,通知方法都增加synchronized锁,但是使用的方式有区别.    
    notifyObservers为了避免整个方法加锁后,update执行阻塞的不可知性,它只将锁放到了状态更新和数据快照复制.这里其实是一种折中,因为快照就意味着新增加和删除的操作不会生效.    
3 void update(Observable o, Object arg);声明中考虑到了参数的传递;    
4 notifyObservers方法重载支持多种通知类型;    
5 ((Observer)arrLocal[i]).update(this, arg);遍历集合中数据,通过this指定当前数据    

- 并发情况下如何线程安全和执行效率:

1 缩小synchronized的范围.就像示例中的notifyObservers方法一样,将方法锁改成方法内局部锁;    
2 使用ReentrantLock锁.一些线程安全的对象就是使用它.比如CopyOnWriteArrayList.它会有更新操作时,增加锁并直接生成新的数据集;这样来避免旧数据的使用. 同时读取操作不加锁,来保证读取的效率   
3 不使用锁.通过CAS+volatile或者Key-value数据结构来保障数据的一致性.效率更高,但是实现较复杂;    

[ArrayList和CopyOnWriteArrayList](https://www.cnblogs.com/simple-focus/p/7439919.html)
[ConcurrentSkipListMap与无锁编程](https://www.cnblogs.com/crazymakercircle/p/13928386.html)


- 单例模式

通过静态方法生成饿汉式单例
```
public class Runtime {
  private static Runtime currentRuntime = new Runtime();

  public static Runtime getRuntime() {
    return currentRuntime;
  }
  
  /** Don't let anyone else instantiate this class */
  private Runtime() {}
  
  //....
  public void addShutdownHook(Thread hook) {
    SecurityManager sm = System.getSecurityManager();
    if (sm != null) {
       sm.checkPermission(new RuntimePermission("shutdownHooks"));
    }
    ApplicationShutdownHooks.add(hook);
  }
  //...
}
```

### Unix中的设计原则

软件开发的难度点:

1. 技术难.要解决的问题比较难,需要比较深的技术解决方案或算法;比如自动驾驶,图像识别,高性能消息队列等    
2. 复杂度.技术不难,但是项目庞大,业务复杂,代码量多,参与开发人多.比如财务系统,物流系统

同样的操作系统作为一个业务系统,它的复杂度也很高,Unix的代码量达到了几百万行,它是如何实现有效的代码管理和开发?    
这个问题可以分为三个角度来分析:
1. 复杂项目的设计原则和思想
2. 复杂项目的管理和开发技巧
3. code review如何保证代码质量

#### 复杂项目的设计原则和思想

- 封装与抽象

一切皆文件.通过抽象访问操作,这样高层的代码就能基于统一的访问方式来访问底层不同类型的设备.隔离底层设备访问的复杂性.简化了上层访问的实现;    
上层代码会更加稳定.抽象可以封装复杂性,隔离异变的实现,提供简单,统一的访问接口.上层代码会更稳定.

- 分层与模块化


















































