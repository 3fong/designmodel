## 代码开发总纲2 - 设计模式

分类:

创建型模式:单例,工厂,构造器模式,原型    
结构型模式:代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式    
行为型模式:观察者模式、模板模式、策略模式、职责链模式、状态模式、迭代器模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。    

创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合或组装”问题，那行为型设计模式主要解决的就是“类或对象之间的交互”问题。

### 创建型模式

创建型模式:单例,工厂,构造器模式,原型  

- 单例:    
一个类全局只允许创建一个对象.这个类就是单例(单一实例).而保障这个对象全局唯一的标准创建规则就是单例模式.价值:全局资源共享.

要素:
```
构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；    
考虑对象创建时的线程安全问题；避免重复创建    
考虑是否支持延迟加载；资源消耗低    
考虑 getInstance() 性能是否高（是否加锁）。
```

分类:饿汉式(先创建对象),懒汉式(按需创建对象)

单例的问题:
```
单例对 OOP 特性的支持不友好    
单例会隐藏类间的依赖关系    
代码扩展性不友好    
可测试性不友好    
不支持有参构造函数    
```

- 工厂模式

由一个类负责同一类方法的创建工作的实现方式.价值:细分类职责,对象结构更清晰.

分类:简单工厂、工厂方法和抽象工厂

简单工厂:一个专门的类实现对象的创建工作.    
工厂方法:接口进行创建行为抽象声明,各个职责对象进行创建实现,各自负责相应的对象创建;通过简单工厂进行对象的创建实现    
抽象工厂:抽象定义多个创建行为,由各个工厂方法具体实现;实际的创建行为更复杂多样    

spring bean创建循环依赖问题:

```
如果循环依赖的类都是SINGLETON，不会出现堆栈溢出
如果循环依赖的类都是PROTOTYPE，本章的代码来看，的确会出现堆栈溢出；解决办法，可以做递归的深度控制。
增加对象创建缓存区,创建前先判断缓存中是否存在.
spring只能解决单例setter模式注入的循环依赖.其他只能调整依赖顺序等方式解决.
```
Bean的作用域:
```
单例(singleton):（默认）每一个Spring IoC容器都拥有唯一的一个实例对象    
原型（prototype）:一个Bean定义，任意多个对象    
请求（request）:一个HTTP请求会产生一个Bean对象，也就是说，每一个HTTP请求都有自己的Bean实例。只在基于web的Spring ApplicationContext中可用    
会话（session）:限定一个Bean的作用域为HTTPsession的生命周期。同样，只有基于web的Spring ApplicationContext才能使用    
全局会话（global session）:限定一个Bean的作用域为全局HTTPSession的生命周期。通常用于门户网站场景，同样，只有基于web的Spring ApplicationContext可用    
```

- 构造器模式

不通过bean中的构造方法和set进行赋值,而是通过特定的链式赋值结构来进行对象的创建;    
价值:支持任意长度参数;创建后不可变;支持多字段复杂校验;    

构造器与工厂模式的区别:
```
工厂模式是全局性的同一类型(继承同一父类或接口的一组子类)对象的创建;实现的不同类的差异化;    
builder是创建同一个class的不同对象,实现类内部的差异化;
```

- 原型模式

通过对象复制来创建对象.    
价值:节省对象创建成本(业务规则处理,网络连接等).    

深拷贝,浅拷贝

### 结构型模式

代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式    

- 代理模式

在不改变原始类代码的情况下,通过引入代理类来给原始类附加功能.    
价值:解耦框架代码和业务代码.   

分类:静态代理(增加新的类,直接包装原始类请求.会直接依赖原始类);动态代理(通过反射来获取原始类,不直接依赖原始类,结构更通用);

- 桥接模式

将抽象和实现解耦,实现可以独立扩展.    
这里的抽象和实现并不仅仅是接口,而是指具体的行为(规则)抽象与实现;将结构上的行为定义与具体实现的具体规则分开定义,以增加扩展性;

比如JDBC与Driver类的灵活组合,Driver就是抽象行为,而oracle,mysql等是具体实现;JDBC只要传入Driver名称,就可以通过反射获取到具体的实现类,实现驱动的初始化;也因此给了驱动实现的扩展性,只要遵循Driver定义就可以使用JDBC的功能

- 装饰器模式

通过组合替代继承,来实现强化原始类的功能,避免层级关系过于复杂.    
为了支持多层包装,装饰器类需要跟原始类继承相同的抽象类或接口;    

装饰器与代理模式:

代理模式是基于原有功能增加新功能;封装所有功能,外部不可知;    
装饰器模式是强化原有功能,实际依旧依赖原有功能的执行;需要显示调用强化功能    
所以具体选择模式时要看是否是强化原有功能;是否需要外部显示调用;

- 适配器模式

让不兼容的接口可以进行兼容适配,可以一同工作;是一种补偿机制,用于补救性的进行接口协调.从而避免一方进行修改;

- 门面模式

为子系统提供一组统一的接口,定义一组高层接口让子系统更易用.    
价值:通过聚合操作,来解决依赖分散的问题.简化调用方的操作    

门面模式实现:    
![门面模式实现](https://box.kancloud.cn/2016-04-20_5717585391597.jpg)

- 组合模式

一种"部分-整体"结构实现上的复用的模式.它将部分的实现与整体的实现进行抽象,部分进行组合就可以获取到整体的实现.适用于树形结构,它要求整体可以复用部分的实现规则;    
价值:通过数据结构来复用实现规则;

- 享元模式

通过单元共享减少资源占用,实现超轻量的与运行.核心是对象复用,节省内存,它的前提是不可变对象.    
价值:资源复用;减少不可变对象的重复创建;    
适用场景:棋牌游戏,它的基本属性是不变的,变化的只是具体的位置或数码;常量类,Integer等


### 行为型模式:

观察者模式、模板模式、策略模式、职责链模式、状态模式、迭代器模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。  

- 观察者模式

在对象间定义一个对多依赖,当一个对象状态改变时,所有的依赖都会收到通知,从而实现自动变化感知;将对象变化与触发及实现进行分类管理,简化依赖;    
价值:降低对象变化的业务耦合,简化依赖代码实现;    
适用场景:注册,订阅等中心操作及其衍生影响行为的场景    

观察者与生产者-消费者模型的区别:    
都是解耦操作;观察者解耦业务依赖;生产者消费者解耦功能依赖;    
实现方式不同:观察者是一对多,可以同步,异步;生产消费者是多对多,一般是异步;

- 模板模式

在一个方法中定义一个算法骨架,并通过将步骤实现推移到子类中,来增强代码扩展性的目的;    
价值:业务整体流程清晰;实现扩展性好;是主要的增加扩展性的方式    

代码的扩展性的提高方式有两种:抽象,多态.模板模式的扩展是基于抽象,本身已经增强了代码的扩展性,这里要强调的是它的核心是为了增强框架的扩展性.

回调:    
回调是一种特殊的模板方式,同时在调用方法中再次调用模板抽象方法,来增加实现的扩展性;

模板模式与回调与hook的关联

- 策略模式

定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。核心是拆分和简化使用    
价值:解耦策略的定义,创建和使用;    

- 职责链模式

将请求和接收解耦,让多个接收对象都有机会处理这个请求.链式调用,直到链上的对象都处理完该请求为止;可以理解为模板模式+链表或数组结构来实现业务规则的横向扩展    
价值:拆分业务规则处理,简化业务规则判断,直接通过数据结构来实现复杂规则判断和执行    
使用场景:敏感词过滤,请求过滤    


- 状态模式

通过建立状态,事件,动作模型特殊的数据结构,来抽象业务规则实现.实现类职责的单一;    
价值:简化实现方式,便于开发和维护    


- 迭代器模式

为了简化及分类不同集合存储对象的操作,将对应的遍历行为单独拆分为模式,用于遍历集合对象.    
价值:抽取公共行为,进一步细化操作     

遍历删除与未决行为

- 访问者模式

通过解耦对象定义和操作定义,来支持对象操作的灵活扩展;这个核心是由于java是单分派语言,它需要在编译时确定方法参数的类型,所以无法对操作实现真正的泛型扩展;像node,它是双分派语言,实际编译时不需要确定方法参数,在运行时才进行确定,所以就不需要访问者这种对于操作的单独定义行为.

- 备忘录模式

在不违背封装原则的前提下,捕获对象的内部状态,并在该对象之外保存这个状态,以便之后恢复对象为先前的状态.    
核心是数据结构和类结构的应用,单一职责.


- 命令模式

将请求(方法)封装为对象,这样就可以将不同请求进行参数化,并能够支持请求的排队执行,记录日志,撤销等功能.    
价值:通过多态+请求封装实现方法的扩展性

- 解释器模式



- 中介模式






























































































参考资料:

[写最好的设计模式](https://www.kancloud.cn/digest/xing-designpattern/143719)












