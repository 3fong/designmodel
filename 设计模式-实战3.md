## 实战3

### 灰度代码发布

灰度发布可以有三个层面:产品层面的灰度、系统层面的灰度和代码实现层面的灰度

#### 需求

将rpc替换为restful,且保证服务不停机

框架的替换要评估可靠性,维护成本,二次开发成本.实际考虑替换方案时也会有两种选择:升级或者完全替换    

    升级的好处是可以做到依赖服务处理兼容,避免大的改动;    
    替换的好处是可以完全避免现有问题,处理更为彻底.

无论哪种方式,都要进行现实业务的验证后才能放心应用,这时就需要进行功能灰度测试,它的问题如下:

1. 灰度规则的应用.代码并行运行,要进行调用方式选择配置,需要一个统一配置进行控制
2. 代码回滚有成本.降低代码回滚影响.代码实现隔离,在调用时控制调用方式选择.来避免实现耦合,从而降低回滚难度.同时调用配置中要支持的配置项包括:接口,灰度比例,特征

需要实现的功能:

灰度发布的功能类似于限流,都是一种网关性质的功能,需要中心处理后,决定下一步的调度.

最小功能原型:

要支持规则通过指定标识,查找到对应的配置,获取到规则后进行解析,获取到规则条件,进而可以和请求中标识比对验证,进行控制要执行那部分的代码实现.

设计的配置文件格式:
```
dark:
  --key: call_newapi_getUserById
   enabled: true // enabled为true时，rule才生效
   rule: {893,342,1020-1120,%30} // 按照用户ID来做灰度
  --key: call_newapi_registerUser
   enabled: true
   rule: {1391198723, %10}  //按照手机号来做灰度
  --key: newalgo_loan
   enabled: true
   rule: {0-1000} //按照贷款(loan)的金额来做灰度
```


功能性需求:

1 定义灰度配置规则,编辑,存储,解析:配置文件格式;配置文件存储方式    
2 调用方式控制(验证是否要进行灰度控制)

自己预先考虑的非功能需求:

容错性:灰度功能异常,不影响业务功能使用;    
安全性:
性能:
扩容:不需要中心节点,统一控制,直接类库集成,系统自治理就好.    
易用性:提供类库.


#### 实现

- 易用性

提供类库    
业务代码低侵入性,修改不影响实际业务代码处理    
热更新.很重要,配置规则修改不用频繁重启服务.    

- 扩展性

通过配置文件,灵活支持配置的规则的调整.

    实现方式:支持不同的配置文件格式.     
    不同存储方式.本地存储,redis,配置中心等

- 性能

不涉及访问外部存储,性能一般不会有太大问题.可以通过重组数据结构,便捷数据查询

- 容错性

实际灰度处理异常是否要中止服务需要结合业务场景进行评估.如果可以接收灰度处理异常的数据执行影响,可以将灰度的请求调度到原来服务上;如果不能接收就直接中止请求.    
实际处理上由于灰度处理的请求处理往往与原来的请求处理有差异,就算路由到原来服务,大概率也无法成功执行,这时中止请求就是比较好的处理方式.实际处理方式的选择,对于不同版本的请求的兼容性有要求,如果请求兼容,不影响实际请求的处理是最好的方式.

#### 自己的思考设计中的问题

考虑问题还是比较片面且不具体.只能浅层的有一些意识,但是实际落地处理以及完善性的考虑还是不足.    
比如易用性,自己只考虑到了集成使用方便,未考虑到代码侵入性问题以及更为切实的热更新问题;    
具体落地处理的细节方面也是没有考虑到,配置文件是进行扩展的最便捷方式,他可以直接影响代码的执行方式.    
对于数据结构的使用意识也比较欠缺,没有性能意识,且没有实际的衡量指标    
服务的异常处理很关键,它是业务处理生命周期的关键部分,实际处理中要进行明确考虑和实现    
自己对于模型示例的理解不足,没有较具体的模型概念,这样就进行功能设计,往往需要返工    

- 实现难点

1 如何支持更灵活,更复杂的灰度规则

比如: 只对30天内购买过某某商品并且退货次数少于10次的用户进行灰度    
这种复杂的规则,如果自定义语法规则,实现的完善度以及要考虑的模型就会很复杂,这时就需要借助框架或者进行定制开发.

a. 使用规则引擎框架处理,比如Drools,eazy-rule,centrldogma.    
b. 自定义实现灰度规则.很可能就成了定制开发.且实现的安全性,扩展性也有一定要求.具体实现可以只提供默认的基本语法规则(具体值,区间值,比例值),复杂规则可以通过扩展接口,支持自定义实现.    

2 如何实现灰度规则热更新

实现方式有两种:事件机制;定时任务.

定时任务是最简单的实现的方式;事件机制较复杂,但是执行更为精准,代码运行资源消耗较少























