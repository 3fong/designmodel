## 创建类模式


### builder模式

对象赋值方式:

1. new是构造方法赋值
2. set赋值
3. 通过代理类进行赋值

| 场景 | 构造方法 | set | builder |
| ---- | ---- | ---- | ---- |
| 参数过多 | v | x | x |
| 字段必填,业务规则校验: | v | x | v |
| 字段间存在依赖关系处理 | v | x | v |
| 创建后不可变 | v | x | v |
| 实现简单 | v | v | x |

set与构造方法往往是互为补充,构造方法中设置必填字段及关联字段校验;set中用于支持非必填字段的赋值;    
但是构造方法的核心问题是:无法解决必填字段很多的场景,只能线性堆积;    
set的核心问题是:无法控制字段必填,无法处理关联字段;也无法满足对象不可变的要求;同时单次只设置部分字段值,可能会存在无效的中间状态.

如:
```
Rectangle r = new Rectange(); // 不设置长宽,长方形是无效的
r.setWidth(2); // 只设置宽也是无效状态
r.setHeight(3); // 长宽都设置才是有效的
```

而builder就是针对复杂的对象赋值操作而提取的设计模式.    
核心设计思想是:先赋值,在最终创建时进行参数统一校验,通过后生成不可变对象.    
它的问题也很直观,就是参数需要重复定义,代码和使用都更复杂一些.

- builder与工厂模式的区别

模式定位不同:

    工厂模式是全局性的同一类型(继承同一父类或接口的一组子类)对象的创建;实现的不同类的差异化;
    builder是创建同一个class的不同对象,实现类内部的差异化;


### 原型模式（Prototype Design Pattern）

原型模式:对对象(原型)进行复制的方式来创建对象,以节省创建成本的目的.

对象创建成本:

1 申请内存,给成员变量赋值;    
2 创建时进行复杂业务处理(排序,计算哈希值等)    
3 从外部获取资源,如rpc,网络,数据库,文件系统等    

2,3的场景中对象的创建成本就会比较高,通过原型模式就可以实现性能和成本的优化.

原型模式在js中应用比较多,在java中比较典型的应用就是clone()方法.

- 深拷贝（Deep Copy）和浅拷贝（Shallow Copy）

浅拷贝:只会复制数据存储索引,不会复制实际的存储数据.    
深拷贝:同时复制数据存储索引和实际存储的数据.

而Object.clone()只是浅拷贝.只会拷贝内存地址.

解决浅拷贝数据干扰的方式:

1. 递归创建所有的对象;
2. 通过序列化和反序列来创建要拷贝的对象.ObjectOutputStream(ByteArrayOutputStream()).writeObject(object);ObjectInputStream(ByteArrayInputStream(bytearr))readObject()
3. 只新建有变动的对象;


#### 数据库删除数据变动如何高效的知道

1. 数据库层面,记录一定时段的删除数据,避免删除数据全量查询;
2. 业务系统方面需要差异项对比.可以通过bloom算法进行;需要全量查询数据.
3. 最好的设计方式是只进行逻辑删除,这样通过时间戳就可以比较出差异项,同时还需要增加数据删除状态.















