## 代码开发总纲

知识体系:

编写高质量可以划分为五个部分:面向对象、设计原则、编码规范、重构技巧、设计模式

![](./preface.png)

概述:

1. 编程范式:包括面向对象,面向过程,面向函数三类,它是语言进行功能实现最基础的设计原则,编程是基于它进行功能实现,相当于语文的总纲.    
2. 设计原则:代码设计的经验总结,对于特定场景下的设计模式应用进行指导和应用标准.比如:开闭原则是策略,模板等模式的指导原则.    
3. 设计模式:是特定场景的可落地的解决方案和设计思路.目的是提高代码的扩展性.设计原则更抽象,而设计模式则更具体,可执行
4. 编程规范:解决可读性问题.比设计原则,设计模式更具体.持续重构的理论基础主要是编程规范.
5. 重构:利用上面标准和指导,进行代码优化,来保证代码在不断的业务功能增加中,满足编程范式,设计原则的要求.


代码优劣的评判标准:

1. 可读性.最基本的标准.遵守编码规范,命名,注释,函数行数,模块划分,高内聚.    
2. 简洁性.实现简洁,能抽取出核心业务规则并进行简化.
3. 可复用性.相同规则进行重用,避免代码重复.
4. 可扩展性.可以不修改或少修改原有代码,采用扩展的方式添加新功能.    
5. 灵活性.包括了扩展性,易用性和复用性.通过简单的方式就能实现新功能
6. 可测试性.能从侧面快速,准确的验证代码质量和功能;比较直接的就是单元测试是否容易编写,且可以覆盖一定功能比例.
7. 可维护性.在不破坏原有代码设计,不引入bug的情况下,快速修改或添加新功能代码.它其实是最高要求,包含了上面的所有标准.



### 面向对象    

- 面向对象,面向过程,面向函数

面对对象:以类或对象作为组织代码的基本单元的编程范式.数据(成员变量,属性)与方法一起实现.    
面向过程:以过程(函数,方法,操作)作为组织代码的基本单元的编程范式.数据(成员变量,属性)与方法分离实现.    
面向函数:以数学函数作为组织代码的基本单元的编程范式.与面向过程有点类似,但是它侧重于用数学公式来表示业务逻辑,方法定义更为抽象.

- 编程范式的区别

面对对象:便于人理解,是以现实世界为模型进行建模实现;通过复杂的结构,来模拟现实业务;本身的条理性就是为了支持复杂业务的开发    
面向过程:便于机器理解,以顺序执行为特点;不需要复杂的结构,通过方法来区分不同的操作;无法支持太复杂的业务;    
面向函数:简化代码,代码实现更为精简,但是不利于人理解,实现也比较复杂;同时应用场景也有限制.目前还在推广中.    


- 面对对象编程的特性:封装,继承,多态,抽象

封装:信息隐藏和数据访问保护.提高易用性,可维护性(访问权限控制)    
继承:通过从属关系,来提高代码复用性    
多态:父类声明,子类在运行时进行实现.提高扩展性和复用性.    
抽象:隐藏具体实现,简化调用方使用.提高扩展性和易用性.    

- 设计思想:

基于抽象而非实现:注重灵活性,扩展性,可维护性    
多用组合少用继承:降低耦合;提高可读性;   

抽象类与接口的价值:

抽象类:is a;主要是复用;    
接口:has a;实现与声明分离,主要是提高扩展性和易用性.

继承的问题:

继承层级不容易控制,代码的堆积会使实现日益复杂;    
不支持多继承;唯一性和执行顺序无法判断;

- 开发流程:分析,设计,编程

分析:搞清楚做什么    
设计:搞清楚怎么做    
编程:将分析和设计翻译成代码

需求分析方法:    

    1 搞清楚实际的问题痛点,这个较深入的了解业务才能发掘    
    2 了解业务方式,最直接的方式就是跟别人聊天沟通;查看文档;查看代码;参考其他公司现有实现    
    3 考虑非业务功能:核心是通用性和可读性
    4 实际的需求分析如果是新产品,一般会经过多次沟通,不断的细化功能,获取最根本的需求


- 设计四环节:

    划分职责并识别出类    
    定义类及属性,方法    
    定义类之间的交互关系    
    组装类并提供执行入口    

设计环节就是开发的基于需求的实现环节,核心是将细化的需求进行分类整理后,形成一个有体系的结构,支持需求功能,并便于理解(可读性),且有一定的扩展性(通用性)

分类方式(类识别):

    1 将需求按生命周期进行罗列    
    2 将生命周期中的步骤进行分类,识别出可以归为一体的步骤进行封装    
    3 基于封装的类识别出应具备的属性和方法    
    4 对这些类进行通用性扩展,抽象接口,并赋以合适的名称(可读性)

类与类的交互关系:

    泛化:继承,有所属关系    
    实现:接口与子接口    
    聚合:包含关系,生命周期可以不相互依赖
    组合:包含关系,一个类负责另一个类的生命周期管理    
    关联:包含聚合,组合;只要成员变量包含另一个类就是关联    
    依赖:包含关联.只有有其他类的引用就是依赖.包括了成员变量,方法参数,返回值等;

### 设计原则

SOLID:单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则

- 单一职责原则:

一个类或模块只负责一个职责.高内聚,低耦合,提高代码复用性,可读性,可维护性;

判断标准:

```
类行数,属性,方法过多;可读性差    
类以来的其他类过多;    
私有方法过多;    
难给类取一个确切的名称,只能比较笼统;    
类中的方法集中操作部分属性;
```

- 开闭原则:

软件实体(模块,类,方法等)应对扩展开发,对修改关闭;

实现方式:

1 设计时要识别出未来不变的部分,可能变化的部分,事先留好扩展点    
2 将可变部分进行封装抽象,未来变化时,可以保证上层声明不变,只要扩展实现即可    
3 常用提高扩展性方法有:多态,依赖注入,基于接口而非实现;设计模式:装饰、策略、模板、职责链、状态等.    
扩展性的核心是抽象方法,来支持通过横向实现或继承的方式来进行实现扩展.比较典型的应用就是模板模式.    
4 尽量让修改操作更集中,更少,更上层,尽量让最核心,最复杂的那部分逻辑代码满足开闭原则.

- 里式替换原则

子类可以替换父类出现的地方,且能保证程序正常正确的执行.核心时按照协议设计.父类就是协议,子类可以改变内部实现,但不能改变约定.子类可以扩展父类功能,但是不能改变父类原有功能

含义:    
```
子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
子类中可以增加自己特有的方法。
当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。
```
这里第一条就是多态与里式替换原则的区别.多态不限制父类非抽象方法的重写;而对于这类方法的重写,往往会造成多态执行异常.因为重写打破了约定.

约定:

```
函数声明要实现的功能;    
对输入,输出,异常的约定;    
注释对于特殊情形的说明
```

- 接口隔离原则

调用方按需使用请求接口.即接口声明中只包含调用方需求的方法;这个感觉有点理想,或者说接口封装要进行分类细化,才能实现这种按需的接口定义.实际服务接口很少能拆分到足够细的粒度.但是可以通过增加抽象层来解决这个问题,相当于所有接口是资源池,根据用户订阅接口,抽象生成对应的调用请求接口,实现了接口声明的隔离;

- 依赖反转原则

高层模块不依赖低层模块.即高层模块和低层模块通过抽象相互引用;抽象不依赖具体实现,具体实现依赖抽象;    

调用者属于高层;被调用者属于低层;如Tomcat是高层,应用程序是底层,中间通过抽象规范Servlet进行相互引用;

spring中的依赖反转:

IOC:控制反转.将执行流程控制交给框架处理;    
DI依赖注入:将对象创建和对象依赖管理交给框架处理;    

正常应该应用管理对象的创建,注入以及对象操作的流程处理(bean刷新,缓存,上下文处理等).但是通过将这些交给spring,用户只要声明对象需要spring管理,以及直接在代码中使用即可.这里spring是高层模块,统一代码声明周期管理;业务代码是低层代码,进行具体实现;

- KISS原则:尽量保持简单

保持代码的可读性和可维护性.代码实现要简单,易理解

- YAGNI:不要过度设计

适当保留扩展点,但是要注意度,超前设计和开发都是无用功

- DRY:不要重复原则

实现逻辑重复,功能语义重复,代码执行重复

- 代码复用性:

减少代码耦合    
满足单一职责原则    
模块化    
业务与非业务逻辑分离    
通用代码下沉    
继承、多态、抽象、封装    
应用模板等设计模式    

- 迪米特法则

最小知识原则.去除不必要依赖.简化实现的依赖内容.高内聚,低耦合.    
比较常用的场景是:    
    文件处理,通过字节数组来接收文件数据,避免具体文件类型依赖;    
    序列化,反序列化


### 编码规范

分三类:命名与注释（Naming and Comments）、代码风格（Code Style）和编程技巧（Coding Tips）

- 命名与注释

命名:

    准确达意    
    根据作用域使用不同的命名长度     
    命名尽量使用通用词汇,缩写要准确    
    遵循统一规范    

注释:

辅助代码理解,包含三部分:是什么,为什么,怎么做,如何用    
注释要概要,复杂方法要尽量全面,便于使用

- 代码风格

函数代码长度尽量在50行内;    
尽量利于阅读    
进行空行分割单元块,明确步骤界限    
参考成熟标准,比如google,ali开发手册

- 编程技巧

1 把复杂函数代码分割成更小的单元块    
2 避免参数过多.    
根据职责按参数拆分为独立的方法;    
将参数封装为对象    
3 函数参数控制逻辑应该放到上层处理,将分支方法封装为函数;    
4 去除多层嵌套,便于理解,简化复杂操作;    
5 使用解释性变量替换魔法数,增强可读性;    


### 重构技巧

通用关注点:

```
目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？    
是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？    
设计模式是否应用得当？是否有过度设计？    
代码是否容易扩展？如果要添加新功能，是否容易实现？    
代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？    
代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？    
代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？    
```

业务功能,非功能需求:

```
代码是否实现了预期的业务需求？    
逻辑是否正确？是否处理了各种异常情况？    
日志打印是否得当？是否方便 debug 排查问题？    
接口是否易用？是否支持幂等、事务等？    
代码是否存在并发问题？是否线程安全？    
性能是否有优化空间，比如，SQL、算法是否可以优化？    
是否有安全漏洞？比如输入输出校验是否全面？    
```

重构:**需要分析代码存在的问题或设计上的不足,并能够合理,熟练的利用设计思想,原则,模式,编程规范等理论知识解决这些问题.**

重构内容分类:

    - 大型重构

    调整类关系结构.包括系统、模块、代码结构、类与类之间的关系等的重构.    
    重构手段:分层、模块化、解耦、抽象可复用组件等等.

    - 小型重构

    对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。

重构方式:

    1 定位需要重构的代码.可使用人工发现(开发中调整不合适的代码);工具检测(checkstyle等)    
    2 理解代码含义,理解里面的需求.梳理出流程图;    
    3 建立防护网.将需求拆分后,针对拆分的业务点写单元测试;    
    4 开始重构,解耦逻辑,将方法职责单一.类与类见最小依赖原则(迪米特原则);命名要规范;职责清晰;    
    5 进行单元测试功能验证.    

- 单元测试:

重构中单元测试很重要,它是评估重构是否满足需求的最基本方法.    
测试用例要覆盖各种输入、异常、边界情况，并将其翻译成代码,保证代码的预期和非预期情况下都能正确执行;    

- 代码可测试性:

1 封装    
2 依赖注入    
3 核心是尽量屏蔽不确定因素,可控才是可测试,明确的代码    

- 解耦
解耦是为了屏蔽复杂性.通过压缩(控制)代码范围,关注点更具体,影响范围也可控,可以提高可读性,可维护性,实现高内聚,低耦合.

解耦方式:

    1 封装与抽象.通过约束代码范围,以及抽取概念,可以避免直接引用,限制代码的影响范围;    
    2 中间层.增加隔离,简化复杂依赖关系;    
    3 模块化.复杂系统的核心就是分工与模块化拆分.这时模块化的拆分,通信,及如何组合工作就是另外一个考验人能力的地方    
    4 单一职责原则:模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低    
    5 基于接口而非实现编程:接口就是中间层    
    6 依赖注入:避免依赖具体实现,生命周期的解耦    
    7 多用组合少用继承:继承的父类改动,会直接影响子类    
    8 迪米特法则:最小依赖原则.    



### 设计模式

分类:

创建型模式:单例,工厂,构造器模式,原型    
结构型模式:代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式    
行为型模式:观察者模式、模板模式、策略模式、职责链模式、状态模式、迭代器模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。    

#### 创建型模式

- 单例:    
一个类全局只允许创建一个对象.这个类就是单例(单一实例).而保障这个对象全局唯一的标准创建规则就是单例模式.价值:全局资源共享.

要素:
```
构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；    
考虑对象创建时的线程安全问题；避免重复创建    
考虑是否支持延迟加载；资源消耗低    
考虑 getInstance() 性能是否高（是否加锁）。
```

分类:饿汉式(先创建对象),懒汉式(按需创建对象)

单例的问题:
```
单例对 OOP 特性的支持不友好    
单例会隐藏类间的依赖关系    
代码扩展性不友好    
可测试性不友好    
不支持有参构造函数    
```

- 工厂模式

由一个类负责同一类方法的创建工作的实现方式.价值:细分类职责,对象结构更清晰.

分类:简单工厂、工厂方法和抽象工厂

简单工厂:一个专门的类实现对象的创建工作.    
工厂方法:接口进行创建行为抽象声明,各个职责对象进行创建实现,各自负责相应的对象创建;通过简单工厂进行对象的创建实现    
抽象工厂:抽象定义多个创建行为,由各个工厂方法具体实现;实际的创建行为更复杂多样    

spring bean创建循环依赖问题:

```
如果循环依赖的类都是SINGLETON，不会出现堆栈溢出
如果循环依赖的类都是PROTOTYPE，本章的代码来看，的确会出现堆栈溢出；解决办法，可以做递归的深度控制。
增加对象创建缓存区,创建前先判断缓存中是否存在.
spring只能解决单例setter模式注入的循环依赖.其他只能调整依赖顺序等方式解决.
```
Bean的作用域:
```
单例(singleton):（默认）每一个Spring IoC容器都拥有唯一的一个实例对象    
原型（prototype）:一个Bean定义，任意多个对象    
请求（request）:一个HTTP请求会产生一个Bean对象，也就是说，每一个HTTP请求都有自己的Bean实例。只在基于web的Spring ApplicationContext中可用    
会话（session）:限定一个Bean的作用域为HTTPsession的生命周期。同样，只有基于web的Spring ApplicationContext才能使用    
全局会话（global session）:限定一个Bean的作用域为全局HTTPSession的生命周期。通常用于门户网站场景，同样，只有基于web的Spring ApplicationContext可用    
```

- 构造器模式

不通过bean中的构造方法和set进行赋值,而是通过特定的链式赋值结构来进行对象的创建;    
价值:支持任意长度参数;创建后不可变;支持多字段复杂校验;    

构造器与工厂模式的区别:
```
工厂模式是全局性的同一类型(继承同一父类或接口的一组子类)对象的创建;实现的不同类的差异化;    
builder是创建同一个class的不同对象,实现类内部的差异化;
```

- 原型模式

通过对象复制来创建对象.    
价值:节省对象创建成本(业务规则处理,网络连接等).    

深拷贝,浅拷贝

#### 结构型模式



































































































参考资料:

[写最好的设计模式](https://www.kancloud.cn/digest/xing-designpattern/143719)












