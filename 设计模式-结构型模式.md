## 结构型模式

结构性模式包括:

代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式

### 代理模式（Proxy Design Pattern）

在不改变原始类代码的情况下,通过引入代理类来给原始类附加功能.常用于将框架代码与业务代码解耦;

实现方式:

1. 通过继承或实现的方式包装原有方法后进行附加功能扩展.
如:
```
// 接口声明
public interface IUserController {
  UserVo login(String telephone, String password);
}
// 接口实现
public class UserController implements IUserController {
  public UserVo login(String telephone, String password) {
    //...返回UserVo数据...
  }
}
// 实现类代理扩展
public class UserControllerProxy implements IUserController {
  private MetricsCollector metricsCollector;
  private UserController userController;
  public UserControllerProxy(UserController userController) {
    this.userController = userController;
    this.metricsCollector = new MetricsCollector();
  }

  @Override
  public UserVo login(String telephone, String password) {
    long startTimestamp = System.currentTimeMillis();

    // 委托
    UserVo userVo = userController.login(telephone, password);

    long endTimeStamp = System.currentTimeMillis();
    long responseTime = endTimeStamp - startTimestamp;
    RequestInfo requestInfo = new RequestInfo("login", responseTime, startTimestamp);
    metricsCollector.recordRequest(requestInfo);
    return userVo;
  }
}
```
最直接的代理方式,但是需要对每一个需要扩展的类创建对应的代理类,同时这些代理类结构还一致.此时可以通过动态代理进行扩展.
2. 动态代理

动态代理（Dynamic Proxy）:就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类.Java的动态代理是基于反射,spring aop的实现就是基于动态代理完成.

```
ublic class MetricsCollectorProxy {
  private MetricsCollector metricsCollector;

  public MetricsCollectorProxy() {
    this.metricsCollector = new MetricsCollector();
  }

  public Object createProxy(Object proxiedObject) {
    Class<?>[] interfaces = proxiedObject.getClass().getInterfaces();
    DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject);
    return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);
  }

  private class DynamicProxyHandler implements InvocationHandler {
    private Object proxiedObject;

    public DynamicProxyHandler(Object proxiedObject) {
      this.proxiedObject = proxiedObject;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
      long startTimestamp = System.currentTimeMillis();
      Object result = method.invoke(proxiedObject, args);
      long endTimeStamp = System.currentTimeMillis();
      long responseTime = endTimeStamp - startTimestamp;
      String apiName = proxiedObject.getClass().getName() + ":" + method.getName();
      RequestInfo requestInfo = new RequestInfo(apiName, responseTime, startTimestamp);
      metricsCollector.recordRequest(requestInfo);
      return result;
    }
  }
}

//MetricsCollectorProxy使用举例
MetricsCollectorProxy proxy = new MetricsCollectorProxy();
IUserController userController = (IUserController) proxy.createProxy(new UserController());
```

一个调用的游戏,实际的执行流程还是顺序调用,通过类的包装,以及特殊的创建的方式,实现这些顺序调用的交叉处理.    
将整个流程拆分为三部分:
1. 业务处理
2. 代理处理,用于扩展业务方法,通过实现指定方法,便于触发类执行.
3. 触发类.动态触发代理处理.

应用场景:

代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。实际上，前面举的搜集接口请求信息的例子，就是这个应用场景的一个典型例子。

因为动态代理中可以获取到请求接口及相应的请求参数,基于这些数据可以做很多扩展.    
比如缓存数据读取.满足指定条件的接口,且请求参数满足指定条件可以进行缓存查询,其他的直接调用.实现缓存和实时查询的功能.


#### 问题 ????

实现了动态代理后,如果debug,程序会触发多次handler.invoke方法的调用.

```
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class CallerProxy {

    public CallerProxy() {
        Login proxy = (Login)this.createProxy(new LoginImpl());
        proxy.login();
    }

    public Object createProxy(Object proxiedObject) {
        Class<?>[] interfaces = proxiedObject.getClass().getInterfaces();
        MeasureHandler handler = new MeasureHandler(proxiedObject);
        return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);
    }
}
class MeasureHandler implements InvocationHandler {
    private Object proxiedObject;

    public MeasureHandler(Object proxiedObject) {
        this.proxiedObject = proxiedObject;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        long starttime = System.currentTimeMillis();
        Object invoke = method.invoke(proxiedObject, args);
        long endtime = System.currentTimeMillis();
        System.out.println("time consuming: "+ (endtime-starttime)+Thread.currentThread());
        return invoke;
    }
}
interface Login {
    void login();
}
class LoginImpl implements Login{
    @Override
    public void login() {
        System.out.println("dengl......"+Thread.currentThread());
    }
}
```

输出结果:
```
time consuming: 3Thread[main,5,main]
time consuming: 2Thread[main,5,main]
dengl......Thread[main,5,main]
time consuming: 1Thread[main,5,main]
time consuming: 2Thread[main,5,main]
time consuming: 7888Thread[main,5,main]
time consuming: 1Thread[main,5,main]
time consuming: 1Thread[main,5,main]
```


### 桥接模式(Bridge Design Pattern)

桥接模式:“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。”

另外一种理解:"一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。"通过组合关系来替代继承关系，避免继承层次的指数级爆炸。

JDBC中桥接的实现:

驱动注册.如果想把mysql换成oracle只需要把com.mysql.jdbc.Driver替换成oracle.jdbc.driver.OracleDriver.
```
Class.forName("com.mysql.jdbc.Driver");//加载及注册JDBC驱动程序
String url = "jdbc:mysql://localhost:3306/sample_db?user=root&password=your_password";
Connection con = DriverManager.getConnection(url);
Statement stmt = con.createStatement()；
String query = "select * from test";
ResultSet rs=stmt.executeQuery(query);
while(rs.next()) {
  rs.getString(1);
  rs.getInt(2);
}
```

jdbc实现原理.

Class.forName("com.mysql.jdbc.Driver")会做两件事:    
1 要求jvm查找并加载该驱动类;    
2 执行驱动类的静态方法java.sql.DriverManager.registerDriver(new Driver());进行驱动注册.

```
package com.mysql.jdbc;
import java.sql.SQLException;

public class Driver extends NonRegisteringDriver implements java.sql.Driver {
	static {
		try {
			java.sql.DriverManager.registerDriver(new Driver());
		} catch (SQLException E) {
			throw new RuntimeException("Can't register driver!");
		}
	}

	/**
	 * Construct a new driver and register it with DriverManager
	 * @throws SQLException if a database error occurs.
	 */
	public Driver() throws SQLException {
		// Required for Class.forName().newInstance()
	}
}
```

驱动注册用于在对jdbc调用时,都会委派给具体的驱动实现类去执行.这样就实现了更新驱动名就更新了实际的驱动.

```
public class DriverManager {
  private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers = new CopyOnWriteArrayList<DriverInfo>();

  //...
  static {
    loadInitialDrivers();
    println("JDBC DriverManager initialized");
  }
  //...

  public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException {
    if (driver != null) {
      registeredDrivers.addIfAbsent(new DriverInfo(driver));
    } else {
      throw new NullPointerException();
    }
  }

  public static Connection getConnection(String url, String user, String password) throws SQLException {
    java.util.Properties info = new java.util.Properties();
    if (user != null) {
      info.put("user", user);
    }
    if (password != null) {
      info.put("password", password);
    }
    return (getConnection(url, info, Reflection.getCallerClass()));
  }
  //...
}
```

- 什么是抽象?什么是实现?

以JDBC为例,抽象:并非抽象类或接口,而是跟具体数据库无关的,被提取出来的一套类库.而实现是具体的Driver.这个实现也不是接口的实现类,而是跟具体数据库相关的一套类库.JDBC和Driver独立开发,通过对象间的组合关系,组装在一起运行.JDBC的所有逻辑操作,最终都委托给Driver来执行.

!!! 感觉类似于spring的按名称获取bean的方式,它从上下文中按名字取对应的方法,并调用它执行.

桥接模式示例

告警通知功能,根据不同级别的消息触发不同的告警信息:

```
public enum NotificationEmergencyLevel {
  SEVERE, URGENCY, NORMAL, TRIVIAL
}

public class Notification {
  private List<String> emailAddresses;
  private List<String> telephones;
  private List<String> wechatIds;

  public Notification() {}

  public void setEmailAddress(List<String> emailAddress) {
    this.emailAddresses = emailAddress;
  }

  public void setTelephones(List<String> telephones) {
    this.telephones = telephones;
  }

  public void setWechatIds(List<String> wechatIds) {
    this.wechatIds = wechatIds;
  }

  public void notify(NotificationEmergencyLevel level, String message) {
    if (level.equals(NotificationEmergencyLevel.SEVERE)) {
      //...自动语音电话
    } else if (level.equals(NotificationEmergencyLevel.URGENCY)) {
      //...发微信
    } else if (level.equals(NotificationEmergencyLevel.NORMAL)) {
      //...发邮件
    } else if (level.equals(NotificationEmergencyLevel.TRIVIAL)) {
      //...发邮件
    }
  }
}

//在API监控告警的例子中，我们如下方式来使用Notification类：
public class ErrorAlertHandler extends AlertHandler {
  public ErrorAlertHandler(AlertRule rule, Notification notification){
    super(rule, notification);
  }


  @Override
  public void check(ApiStatInfo apiStatInfo) {
    if (apiStatInfo.getErrorCount() > rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) {
      notification.notify(NotificationEmergencyLevel.SEVERE, "...");
    }
  }
}
```
问题:if-else中含有大量复杂业务,不利于开发和维护.

针对上面的问题通过桥接模式进行改造:

Notification相当于抽象,MsgSender相当于实现.两个独立开发,通过组合关系任意组合在一起.不同紧急程度的消息和发送渠道间的对应关系,不在代码中固定写死,而是动态指定.


```
public interface MsgSender {
  void send(String message);
}

public class TelephoneMsgSender implements MsgSender {
  private List<String> telephones;

  public TelephoneMsgSender(List<String> telephones) {
    this.telephones = telephones;
  }

  @Override
  public void send(String message) {
    //...
  }

}

public class EmailMsgSender implements MsgSender {
  // 与TelephoneMsgSender代码结构类似，所以省略...
}

public class WechatMsgSender implements MsgSender {
  // 与TelephoneMsgSender代码结构类似，所以省略...
}

public abstract class Notification {
  protected MsgSender msgSender;

  public Notification(MsgSender msgSender) {
    this.msgSender = msgSender;
  }

  public abstract void notify(String message);
}

public class SevereNotification extends Notification {
  public SevereNotification(MsgSender msgSender) {
    super(msgSender);
  }

  @Override
  public void notify(String message) {
    msgSender.send(message);
  }
}

public class UrgencyNotification extends Notification {
  // 与SevereNotification代码结构类似，所以省略...
}
public class NormalNotification extends Notification {
  // 与SevereNotification代码结构类似，所以省略...
}
public class TrivialNotification extends Notification {
  // 与SevereNotification代码结构类似，所以省略...
}
```






















































































































