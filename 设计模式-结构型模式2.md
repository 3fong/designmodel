## 结构性模式2


### 门面模式

门面模式,也叫外观模式(Facade Design Pattern):为子系统提供一组统一的接口,定义一组高层接口让子系统更易用.

实际就是基于实际的接口封装一组更为专用的接口,让该接口的调用方使用更简单.    
尽量保持接口的可复用性,但是特殊情况下,允许提供冗余的门面接口,来提供更易用的接口.这是在复用性和易用性上的权衡.

比如:service有a,b,c,d四个接口;但是A只需要其中的a,b,d三个,我们就可以抽象一个只包含a,b,d的接口给A使用,这样A可以自己组装接口使用方式,不用再判断哪些是自己要用的.就比如为了加速页面响应,我们可以再将a,b,d封装到一个接口e中,这样本身三次请求就变成了一次.这样来看门面就是一个专用的controller.可以基于service做多种封装来简化调用.

但是问题也很明显,过多的门面接口会造成代码不通用.

#### 使用场景

1. 解决易用性问题.封装底层实现,对外提供一组更简单易用,更高层的接口.最简单的应用场景就是sdk的使用.

    隐藏实现复杂性,提供更简单易用接口的意图与迪米特法则(最少知识原则)和接口隔离原则类似:两个有交互的系统,只暴露有限的必要接口.还应用了封装,抽象的设计思想,提供更抽象的接口,封装底层实现.对于同一个道理从不同角度进行阐述,就是设计原则,思想,模式的区分.

2. 解决性能问题.

如何分配门面接口和非门面接口?     
```
如果门面接口不多,可以不单独管理门面接口.    
如果门面接口很多,可以抽象出门面接口,从类,包命名上跟原来的接口层做区分.    
如果门面接口非常多,且跨多个子系统,可以将门面接口单独抽离成模块或系统
```

3. 解决分布式事务问题.这个只能接口跨表事务问题,无法解决跨库事务的问题.因为无法基于一个数据库来管理事务.

实现方式将原本的多个接口调用,放到一个接口中,在单个接口中使用事务来管理.核心是利用数据库事务和spring框架事务.

#### 适配器模式和门面模式的区别

1. 共同点,都是提高调用易用性.
2. 价值不同:

适配器的核心是转换,解决原接口与目标接口不匹配的问题;    
门面模式的核心是抽象,通过专用来提高易用性.



### 组合模式

组合模式:Composite Design Pattern.将一组对象组织(compose)成树形结构,以表示一种"部分-整体"的层级结构.通过组合部分为整体,可以让客户端统一单一对象和组合对象的处理.

它是利用了树结构的特性,基于单个叠加成整体.实现处理逻辑在单个和多个间的复用.实际的应用场景只适合树形结构的问题.它与面向对象设计中"组合关系"是两回事.

#### 示例1 文件计数和文件大小汇总

需求:

动态地添加、删除某个目录下的子目录或文件；    
统计指定目录下的文件个数；    
统计指定目录下的文件总大小。    

根据需要我们很正常的分析出来,一个目录下可能存在目录或者文件,所以需要一个文件判断标识;    
同时只有文件有实际的数量和大小;单个文件的数量为1;目录的文件数量和大小需要遍历所有的文件后得出.    
同时需要进行增删操作,需要一个存储体来存储该目录下的目录和文件.由于文件并不需要进行排序和加速检索的需求,存到数组里进操作最简单.
```
public class FileSystemNode {
  private String path;
  private boolean isFile;
  private List<FileSystemNode> subNodes = new ArrayList<>();

  public FileSystemNode(String path, boolean isFile) {
    this.path = path;
    this.isFile = isFile;
  }

   public int countNumOfFiles() {
    if (isFile) {
      return 1;
    }
    int numOfFiles = 0;
    for (FileSystemNode fileOrDir : subNodes) {
      numOfFiles += fileOrDir.countNumOfFiles();
    }
    return numOfFiles;
  }

  public long countSizeOfFiles() {
    if (isFile) {
      File file = new File(path);
      if (!file.exists()) return 0;
      return file.length();
    }
    long sizeofFiles = 0;
    for (FileSystemNode fileOrDir : subNodes) {
      sizeofFiles += fileOrDir.countSizeOfFiles();
    }
    return sizeofFiles;
  }

  public String getPath() {
    return path;
  }

  public void addSubNode(FileSystemNode fileOrDir) {
    subNodes.add(fileOrDir);
  }

  public void removeSubNode(FileSystemNode fileOrDir) {
    int size = subNodes.size();
    int i = 0;
    for (; i < size; ++i) {
      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {
        break;
      }
    }
    if (i < size) {
      subNodes.remove(i);
    }
  }
}
```

扩展:

从功能实现上,上面的代码已经满足了需求;但是从扩展性(文件和目录可能有不同的操作),业务建模(文件,目录是两个概念),代码可读性(文件,目录分开,更利于理解)角度来看,最好将两部分分开;

```
// 提取公共方法和抽象方法
public abstract class FileSystemNode {
  protected String path;

  public FileSystemNode(String path) {
    this.path = path;
  }

  public abstract int countNumOfFiles();
  public abstract long countSizeOfFiles();

  public String getPath() {
    return path;
  }
}

// 文件定义更简单
public class File extends FileSystemNode {
  public File(String path) {
    super(path);
  }

  @Override
  public int countNumOfFiles() {
    return 1;
  }

  @Override
  public long countSizeOfFiles() {
    java.io.File file = new java.io.File(path);
    if (!file.exists()) return 0;
    return file.length();
  }
}

// 目录中存在计算的方法,职责划分也更清晰
public class Directory extends FileSystemNode {
  private List<FileSystemNode> subNodes = new ArrayList<>();

  public Directory(String path) {
    super(path);
  }

  @Override
  public int countNumOfFiles() {
    int numOfFiles = 0;
    for (FileSystemNode fileOrDir : subNodes) {
      numOfFiles += fileOrDir.countNumOfFiles();
    }
    return numOfFiles;
  }

  @Override
  public long countSizeOfFiles() {
    long sizeofFiles = 0;
    for (FileSystemNode fileOrDir : subNodes) {
      sizeofFiles += fileOrDir.countSizeOfFiles();
    }
    return sizeofFiles;
  }

  public void addSubNode(FileSystemNode fileOrDir) {
    subNodes.add(fileOrDir);
  }

  public void removeSubNode(FileSystemNode fileOrDir) {
    int size = subNodes.size();
    int i = 0;
    for (; i < size; ++i) {
      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {
        break;
      }
    }
    if (i < size) {
      subNodes.remove(i);
    }
  }
}

// 调用

 public static void main(String[] args) {
    /**
     * /
     * /wz/
     * /wz/a.txt
     * /wz/b.txt
     */
    Directory fileSystemTree = new Directory("/");
    Directory node_wz = new Directory("/wz/");
    fileSystemTree.addSubNode(node_wz);

    File node_wz_a = new File("/wz/a.txt");
    File node_wz_b = new File("/wz/b.txt");
    node_wz.addSubNode(node_wz_a);
    node_wz.addSubNode(node_wz_b);

    System.out.println("/ files num:" + fileSystemTree.countNumOfFiles());
    System.out.println("/wz/ files num:" + node_wz.countNumOfFiles());
  }
```













