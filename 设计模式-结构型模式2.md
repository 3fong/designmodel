## 结构性模式2


### 门面模式

门面模式,也叫外观模式(Facade Design Pattern):为子系统提供一组统一的接口,定义一组高层接口让子系统更易用.

实际就是基于实际的接口封装一组更为专用的接口,让该接口的调用方使用更简单.    
尽量保持接口的可复用性,但是特殊情况下,允许提供冗余的门面接口,来提供更易用的接口.这是在复用性和易用性上的权衡.

比如:service有a,b,c,d四个接口;但是A只需要其中的a,b,d三个,我们就可以抽象一个只包含a,b,d的接口给A使用,这样A可以自己组装接口使用方式,不用再判断哪些是自己要用的.就比如为了加速页面响应,我们可以再将a,b,d封装到一个接口e中,这样本身三次请求就变成了一次.这样来看门面就是一个专用的controller.可以基于service做多种封装来简化调用.

但是问题也很明显,过多的门面接口会造成代码不通用.

#### 使用场景

1. 解决易用性问题.封装底层实现,对外提供一组更简单易用,更高层的接口.最简单的应用场景就是sdk的使用.

    隐藏实现复杂性,提供更简单易用接口的意图与迪米特法则(最少知识原则)和接口隔离原则类似:两个有交互的系统,只暴露有限的必要接口.还应用了封装,抽象的设计思想,提供更抽象的接口,封装底层实现.对于同一个道理从不同角度进行阐述,就是设计原则,思想,模式的区分.

2. 解决性能问题.

如何分配门面接口和非门面接口?     
```
如果门面接口不多,可以不单独管理门面接口.    
如果门面接口很多,可以抽象出门面接口,从类,包命名上跟原来的接口层做区分.    
如果门面接口非常多,且跨多个子系统,可以将门面接口单独抽离成模块或系统
```

3. 解决分布式事务问题.这个只能接口跨表事务问题,无法解决跨库事务的问题.因为无法基于一个数据库来管理事务.

实现方式将原本的多个接口调用,放到一个接口中,在单个接口中使用事务来管理.核心是利用数据库事务和spring框架事务.

#### 适配器模式和门面模式的区别

1. 共同点,都是提高调用易用性.
2. 价值不同:

适配器的核心是转换,解决原接口与目标接口不匹配的问题;    
门面模式的核心是抽象,通过专用来提高易用性.



### 组合模式

组合模式:Composite Design Pattern.将一组对象组织(compose)成树形结构,以表示一种"部分-整体"的层级结构.通过组合部分为整体,可以让客户端统一单一对象和组合对象的处理.

它是利用了树结构的特性,基于单个叠加成整体.实现处理逻辑在单个和多个间的复用.实际的应用场景只适合树形结构的问题.

















