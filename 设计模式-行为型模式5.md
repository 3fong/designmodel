## 行为型模式5

### 访问者模式

访问者模式:是一种将数据操作和数据结构分离的设计模式.

- 使用场景

1 数据结构稳定,但是数据操作需要灵活扩展;    
2 数据操作变动不希望影响已有的行为;

访问者模式UML类图

!访问者模式UML类图](https://upload-images.jianshu.io/upload_images/7345261-f1b6fe6189c026da.png?imageMogr2/auto-orient/strip|imageView2/2/w/840/format/webp)

类说明:

Visitor:访问者(数据行为)接口或抽象类.定义了数据结构(Element)的访问行为,它的参数就是访问者的数据结构;    
ImplVisitor:访问者实现类.定义每个数据结构的具体行为,它的参数就是数据结构的实现类.它是该模式的主要扩展点;    
Element:数据结构接口或抽象类.它定义了一个接收访问者的方法:accept(Visitor).其保证每个数据结构都可以有自己的数据行为(访问行为).访问者模式要求Element的定义稳定,否则就需要频繁的修改所有visitor,就不适合使用该模式.    
ImplElement:数据结构实现类.用于定义具体的数据结构,这个数据结构就是访问者行为的方法参数.    
ObjectStructure:用于管理对象结构,绑定数据结构与数据行为(visitor可能有多个)的关联.    

#### 示例

需求: 年底，CEO和CTO开始评定员工一年的工作绩效，员工分为工程师和经理，CTO关注工程师的代码量、经理的新产品数量；CEO关注的是工程师的KPI和经理的KPI以及新产品数量。
由于CEO和CTO对于不同员工的关注点是不一样的，这就需要对不同员工类型进行不同的处理。访问者模式此时可以派上用场了。

- 正常写法

1 往往将行为直接写到实体定义中,这种是编写最简单,但是扩展性是最差的,因为数据结构稳定,但是数据行为多样,只要数据行为要调整基本所有的数据结构类都需要进行修改;    
2 抽离数据行为到单独的一个类里,进行条件判断,有点类似于策略模式.这种将变化内容隔离到单独的里,这样如果行为修改只需要修改一个类即可.不好的地方是这个类会逐渐变大,然后就是变动可能性很高.可读性会越来越差.    

```
public class ReportUtil {
    public void visit(Staff staff) {
        if (staff instanceof Manager) {
            Manager manager = (Manager) staff;
            System.out.println("经理: " + manager.name + ", KPI: " + manager.kpi +
                    ", 新产品数量: " + manager.getProducts());
        } else if (staff instanceof Engineer) {
            Engineer engineer = (Engineer) staff;
            System.out.println("工程师: " + engineer.name + ", KPI: " + engineer.kpi);
        }
    }
}
```

- 访问者模式的写法

1 定义数据结构

这里一般会抽象出数据结构element类,再定义数据结构实现类;accept方法用于关联数据结构与数据行为visitor.数据结构要求相对稳定.
```
// 数据结构基类
public abstract class Staff {

    public String name;
    public int kpi;// 员工KPI

    public Staff(String name) {
        this.name = name;
        kpi = new Random().nextInt(10);
    }
    // 核心方法，接受Visitor的访问
    public abstract void accept(Visitor visitor);
}

// 工程师
public class Engineer extends Staff {

    public Engineer(String name) {
        super(name);
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
    // 工程师一年的代码数量
    public int getCodeLines() {
        return new Random().nextInt(10 * 10000);
    }
}

// 经理
public class Manager extends Staff {

    public Manager(String name) {
        super(name);
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
    // 一年做的产品数量
    public int getProducts() {
        return new Random().nextInt(10);
    }
}
```
2 定义visitor类

不同的访问者,行为不一样.这里是访问者扩展的关键.重载的 visit 方法会对元素进行不同的操作，而通过注入不同的 Visitor 又可以替换掉访问者的具体实现，使得对元素的操作变得更灵活，可扩展性更高，同时也消除了类型转换、if-else 等“丑陋”的代码。

```
// 行为接口
public interface Visitor {

    // 访问工程师类型
    void visit(Engineer engineer);

    // 访问经理类型
    void visit(Manager manager);
}

// CEO访问者
public class CEOVisitor implements Visitor {
    @Override
    public void visit(Engineer engineer) {
        System.out.println("工程师: " + engineer.name + ", KPI: " + engineer.kpi);
    }

    @Override
    public void visit(Manager manager) {
        System.out.println("经理: " + manager.name + ", KPI: " + manager.kpi +
                ", 新产品数量: " + manager.getProducts());
    }
}

public class CTOVisitor implements Visitor {
    @Override
    public void visit(Engineer engineer) {
        System.out.println("工程师: " + engineer.name + ", 代码行数: " + engineer.getCodeLines());
    }

    @Override
    public void visit(Manager manager) {
        System.out.println("经理: " + manager.name + ", 产品数量: " + manager.getProducts());
    }
}
```

3 关联数据结构和数据行为
```
// 员工业务报表类
public class BusinessReport {

    private List<Staff> mStaffs = new LinkedList<>();

    public BusinessReport() {
        mStaffs.add(new Manager("经理-A"));
        mStaffs.add(new Engineer("工程师-A"));
        mStaffs.add(new Engineer("工程师-B"));
        mStaffs.add(new Engineer("工程师-C"));
        mStaffs.add(new Manager("经理-B"));
        mStaffs.add(new Engineer("工程师-D"));
    }

    /**
     * 为访问者展示报表
     * @param visitor 公司高层，如CEO、CTO
     */
    public void showReport(Visitor visitor) {
        for (Staff staff : mStaffs) {
            staff.accept(visitor);
        }
    }
}
```

4 客户端调用

```
public class Client {

    public static void main(String[] args) {
        // 构建报表
        BusinessReport report = new BusinessReport();
        System.out.println("=========== CEO看报表 ===========");
        report.showReport(new CEOVisitor());
        System.out.println("=========== CTO看报表 ===========");
        report.showReport(new CTOVisitor());
    }
}
// 输出结果
=========== CEO看报表 ===========
经理: 经理-A, KPI: 9, 新产品数量: 0
工程师: 工程师-A, KPI: 6
工程师: 工程师-B, KPI: 6
工程师: 工程师-C, KPI: 8
经理: 经理-B, KPI: 2, 新产品数量: 6
工程师: 工程师-D, KPI: 6
=========== CTO看报表 ===========
经理: 经理-A, 产品数量: 3
工程师: 工程师-A, 代码行数: 62558
工程师: 工程师-B, 代码行数: 92965
工程师: 工程师-C, 代码行数: 58839
经理: 经理-B, 产品数量: 6
工程师: 工程师-D, 代码行数: 53125
```

在上述示例中，Staff 扮演了 Element 角色，而 Engineer 和 Manager 都是 ConcreteElement；CEOVisitor 和 CTOVisitor 都是具体的 Visitor 对象；而 BusinessReport 就是 ObjectStructure；Client就是客户端代码。
访问者模式最大的优点就是增加访问者非常容易，我们从代码中可以看到，如果要增加一个访问者，只要新实现一个 Visitor 接口的类，从而达到数据对象与数据操作相分离的效果。如果不使用访问者模式，而又不想对不同的元素进行不同的操作，那么必定需要使用 if-else 和类型转换，这使得代码难以升级维护。

#### 优缺点

访问者模式的优点。

- 各角色职责分离，符合单一职责原则    
通过UML类图和上面的示例可以看出来，Visitor、ConcreteVisitor、Element 、ObjectStructure，职责单一，各司其责。    
- 具有优秀的扩展性    
如果需要增加新的访问者，增加实现类 ConcreteVisitor 就可以快速扩展。    
- 使得数据结构和作用于结构上的操作解耦，使得操作集合可以独立变化    
员工属性（数据结构）和CEO、CTO访问者（数据操作）的解耦。    
- 灵活性    

访问者模式的缺点。

- 具体元素对访问者公布细节，违反了迪米特原则    
CEO、CTO需要调用具体员工的方法。    
- 具体元素变更时导致修改成本大    
变更员工属性时，多个访问者都要修改。    
- 违反了依赖倒置原则，为了达到“区别对待”而依赖了具体类，没有以来抽象    
访问者 visit 方法中，依赖了具体员工的具体方法。    


#### 参考资料

[访问者模式一篇就够了](https://www.jianshu.com/p/1f1049d0a0f4)











